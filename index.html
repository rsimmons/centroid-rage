<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Centroid Rage: Balance Sheeit</title>
<meta name="viewport" content="width=device-width">
<style type="text/css">
body {
    overflow: hidden;
    font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
}

#main {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
}

#control-panel {
    display: block;
    position: fixed;
    top: 0;
    right: 0;
    padding: 5px;
    box-sizing: border-box;
    background-color: rgba(87,107,133,0.8);
}

#control-panel div {
    margin-top: 2px;
}

.drag-pad {
    display: inline-block;
    background-color: darkgrey;
    padding: 5px;
    border: 1px solid black;
    cursor: pointer;
}
</style>
</head>
<body>
<div id="main"></div>
<div id="control-panel">
    <div><input name="import-file-input" type="file" id="import-file-input"><button id="import-file-button">Import</button></div>
    <div><button id="set-output-button">Set Output</button><button id="add-input-button">Add Input</button></div>
    <div>Output <label>Depth<input name="output-depth" type="text" id="output-depth" size="5" placeholder="depth" value="1.0"></label></div>
    <div>Input <label>Depth</label><input name="input-depth" id="input-depth" type="text" size="5" placeholder="depth" value="1.0"> <label>Weight</label><input type="text" name="input-weight" id="input-weight" size="5" placeholder="weight" value="1.0"></div>
    <div><button id="balance-button">Balance</button></div>
    <div><div id="rotate-pad" class="drag-pad">Rotate</div></div>
    <div><button id="clear-button">Clear</button></div>
    <div><label>Cursor: <span id="cursor-display"></span></label></div>
    <div><label>Area: <span id="area-display"></span></label></div>
    <div><label>Base Width: <span id="base-width-display"></span></label></div>
    <div><label>Critical Angle: <span id="crit-angle-display"></span></label></div>
</div>
<script>
"use strict";

function assert(test) {
    if (!test) {
        throw "assertion fail";
    }
}

function mergeUpdate(o1, o2) {
    // copy properties of o2 into o1, return o1
    for (var k in o2) {
        if (o2.hasOwnProperty(k)) {
            o1[k] = o2[k];
        }
    }

    return o1;
}

function isEmpty(obj) {
   for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
         return false;
      }
   }
   return true;
}
var SVGNS = "http://www.w3.org/2000/svg";

function svgElem(name, attrs) {
    var elem = document.createElementNS(SVGNS, name);

    if (attrs) {
        for (var k in attrs) {
            if (attrs.hasOwnProperty(k)) {
                elem.setAttributeNS(null, k, attrs[k]);
            }
        }
    }

    return elem;
}

function getTransformBetween(fromElem, toElem) {
    // should be able to use built-in fromElem.getTransformToElement(toElem),
    //  but buggy in some browsers when crossing nested svg elements.
    //  see https://bugs.webkit.org/show_bug.cgi?id=86010
    return toElem.getScreenCTM().inverse().multiply(fromElem.getScreenCTM());
}

function removeAllChildren(elem) {
    while (elem.hasChildNodes()) {
        elem.removeChild(elem.childNodes[0]);
    }
}

function pointCopy(p) {
    return {x: p.x, y: p.y};
}

function pointSub(a, b) {
    return {x: a.x - b.x, y: a.y - b.y};
}

function vecDot(a, b) {
    return a.x*b.x + a.y*b.y;
}

function pointDist(a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
}

function pointDistSqr(a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return dx*dx + dy*dy;
}

function normalDiff(from, to) {
    var dx = to.x - from.x;
    var dy = to.y - from.y;
    var invmag = 1.0/Math.sqrt(dx*dx + dy*dy);
    return {x: invmag*dx, y: invmag*dy};
}

function pointInsideHalfspace(p, h) {
    return (p.x*h.a + p.y*h.b + h.c) > 0;
}

function polySignedArea(poly) {
    var sum = 0;
    for (var i = 0; i < poly.length; i++) {
        var i1 = (i+1) % poly.length;
        sum += poly[i].x*poly[i1].y - poly[i1].x*poly[i].y;
    }
    return 0.5*sum;
}

// from http://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon
function polyCentroid(poly) {
    var area = polySignedArea(poly);
    if (area === 0) { // TODO: could check against an epsilon instead
        var xsum = 0, ysum = 0;
        for (var i = 0; i < poly.length; i++) {
            xsum += poly[i].x;
            ysum += poly[i].y;
        }
        var factor = 1.0/poly.length;
        return {x: factor*xsum, y: factor*ysum};
    }

    var xsum = 0, ysum = 0;

    for (var i = 0; i < poly.length; i++) {
        var i1 = (i+1) % poly.length;
        var sub = poly[i].x*poly[i1].y - poly[i1].x*poly[i].y;
        xsum += sub*(poly[i].x + poly[i1].x);
        ysum += sub*(poly[i].y + poly[i1].y);
    }

    var factor = 1.0/(6*area);
    return {x: factor*xsum, y: factor*ysum};
}

// return index of polygon vertex that is nearest to point p, within given radius. null if no vertex within radius
function nearestVertex(poly, p, radius) {
    var radSqr = radius*radius;
    var nearestIndex = null;
    var nearestDistSqr;

    for (var i = 0; i < poly.length; i++) {
        var distSqr = pointDistSqr(poly[i], p);
        if ((distSqr <= radius) && ((nearestDistSqr === undefined) || (distSqr < nearestDistSqr))) {
            nearestIndex = i;
            nearestDistSqr = distSqr;
        }
    }

    return nearestIndex;
}

function cutPolygon(polygon, allowedSegments, approachDir, depth) {
    // find maximum dot product against approach direction that is within output region
    var minDot = undefined;
    for (var i = 0; i < polygon.length; i++) {
        if (isEmpty(allowedSegments) || allowedSegments.hasOwnProperty(i)) {
            var d1 = vecDot(polygon[i], approachDir);
            if ((minDot === undefined) || (d1 < minDot)) {
                minDot = d1;
            }

            var d2 = vecDot(polygon[(i+1)%polygon.length], approachDir);
            if ((minDot === undefined) || (d2 < minDot)) {
                minDot = d2;
            }
        }
    }

    // figure out cutting halfspace. we retain the parts in the positive part of the halfspace, so this is really the "not-cut-away halfspace"
    var cutHalfspace = {a: approachDir.x, b: approachDir.y, c: -minDot - depth};

    // do the cut
    var cutPoly = []; // result of cutting
    var inCut = !pointInsideHalfspace(polygon[0], cutHalfspace); // are we in cut-away part?
    var cutIntersections = []; // points where polygon crossed cut
    for (var segIdx = 0; segIdx < polygon.length; segIdx++) {
        var segStart = polygon[segIdx];
        var segEnd = polygon[(segIdx+1)%polygon.length];

        if (isEmpty(allowedSegments) || allowedSegments.hasOwnProperty(segIdx)) {
            // test segment against cutting line
            var segV = pointSub(segEnd, segStart);
            var denom = cutHalfspace.a*segV.x + cutHalfspace.b*segV.y;
            var t = undefined;

            if (denom !== 0) {
                t = -(cutHalfspace.a*segStart.x + cutHalfspace.b*segStart.y + cutHalfspace.c)/denom;
            }

            if ((t !== undefined) && (t > 0) && (t <= 1)) {
                var inter = {x: segStart.x + t*segV.x, y: segStart.y + t*segV.y};

                cutIntersections.push(inter);

                if (inCut) {
                    // coming out of cut back to un-cut

                    cutPoly.push(inter); // add intersection point

                    inCut = false; // no longer in cut

                    cutPoly.push(pointCopy(segEnd));
                } else {
                    // going into cut
                    cutPoly.push(inter); // add intersection point

                    inCut = true;
                }
            } else {
                // segment does not cross cutting line
                if (inCut) {
                    // inside cut, so ignore this segment
                } else {
                    // outside cut, so copy of segment endpoint
                    cutPoly.push(pointCopy(segEnd));
                }
            }
        } else {
            assert(inCut === false); // should have come back out of cut if we aren't in output region
            cutPoly.push(pointCopy(segEnd));
        }
    }

    // now that we've cut the poly, find the extrema of the intersection points
    // left and right make sense if approach dir is upward, i.e. cutting up from below
    assert(cutIntersections.length >= 2);
    var leftmostIntersection = null, rightmostIntersection = null;
    var leftmostDot = undefined, rightmostDot = undefined;
    var rightVec = {x: -approachDir.y, y: approachDir.x};
    for (var i = 0; i < cutIntersections.length; i++) {
        var dot = vecDot(rightVec, cutIntersections[i]);
        if ((rightmostDot === undefined) || (dot > rightmostDot)) {
            rightmostIntersection = cutIntersections[i];
            rightmostDot = dot;
        }
        if ((leftmostDot === undefined) || (dot < leftmostDot)) {
            leftmostIntersection = cutIntersections[i];
            leftmostDot = dot;
        }
    }

    return {cutPoly: cutPoly, leftmostIntersection: leftmostIntersection, rightmostIntersection: rightmostIntersection};
}

document.addEventListener("DOMContentLoaded", function() {
    var rootSVGElem = svgElem("svg", {version: "1.1"});

    var bg = svgElem("rect", {x: "0", y: "0", width: "100%", height: "100%", fill: "rgb(100,100,100)", stroke: "none"});
    rootSVGElem.appendChild(bg);

    var innerSVGElem = svgElem("svg", {version: "1.1", viewBox: "-0.5 -0.5 1 1"});
    rootSVGElem.appendChild(innerSVGElem);

    var viewTransformGroupElem = svgElem("g");
    innerSVGElem.appendChild(viewTransformGroupElem);

    var modelTransformGroupElem = svgElem("g");
    viewTransformGroupElem.appendChild(modelTransformGroupElem);

    var polyContainerElem = svgElem("g");
    modelTransformGroupElem.appendChild(polyContainerElem);

    var highlightContainerElem = svgElem("g");
    modelTransformGroupElem.appendChild(highlightContainerElem);

    // make selection box container but child of root, so that its coordinates are scaled 1 to 1 with pixels
    var selectBoxContainerElem = svgElem("g");
    rootSVGElem.appendChild(selectBoxContainerElem);

    // polygon
    var polygon = null; // array of objects with x and y attrs
    var polygonElem = null;
    var centroidElem = null;

    var baseLeftCorner = null, baseRightCorner = null; // points, not index

    var highlightedVertexIndex = null;
    var vertexHighlightElem = null;

    document.getElementById("main").appendChild(rootSVGElem);

    // interaction
    var MODE_NOTHING = 0;
    var MODE_DRAW = 1;
    var MODE_PAN = 2;
    var MODE_ROTATE = 3;
    var MODE_SELECT_BOX = 4;
    var currentMode = MODE_NOTHING;

    var lastMousePos;
    var interactionElem = rootSVGElem;
    var dragPrev = null;

    var selectBoxStart = null, selectBoxEnd = null; // in page coords
    var selectBoxElem = null;
    var selectedSegments = {}; // set of segment indexes. segment index i is from vertex i to i+1

    var outputSegments = {};
    var inputSegmentsList = [];

    var panSumX = 0, panSumY = 0;
    var zoomLog = -6; // NOTE: default zoom level is somewhat arbitrary
    var rotation = 0;

    updateViewTransforms();

    function pageToElemCoords(pageCoords, elem) {
        var m = elem.getScreenCTM();
        var p = rootSVGElem.createSVGPoint();
        p.x = pageCoords.x;
        p.y = pageCoords.y;
        p = p.matrixTransform(m.inverse());
        return {x: p.x, y: p.y};
    }

    function eventToElemCoords(event, elem) {
        // return coords of event in coord space of element
        var pageCoords = {x: event.pageX, y: event.pageY};
        return pageToElemCoords(pageCoords, elem);
    }

    function updateViewTransforms(zoom) {
        var zoom = Math.exp(zoomLog);
        var rotDegrees = 180*rotation/Math.PI;
        viewTransformGroupElem.setAttributeNS(null, "transform", "scale(" + zoom + ") translate(" + panSumX + "," + panSumY + ")");
        modelTransformGroupElem.setAttributeNS(null, "transform", "rotate(" + rotDegrees + ")");
    }

    function updatePolygonElem() {
        // compute "zoom correction factor", so we can draw stuff in polyContainerElem (mostly stroke widths) and have it come out in certain screen space scale
        var m = polyContainerElem.getScreenCTM();
        var zoomCorrection = 1.0/(0.5*(m.a+m.d));

        if (polygon) {
            if (!polygonElem) {
                polygonElem = svgElem("path");
                polyContainerElem.appendChild(polygonElem);

                centroidElem = svgElem("circle", {fill: "red", r: "1"});
                polyContainerElem.appendChild(centroidElem);
            }
            var dataStr = "";
            dataStr += "M " + polygon[0].x + " " + polygon[0].y + " ";
            for (var i = 1; i < polygon.length; i++) {
                var p = polygon[i];
                dataStr += "L " +  p.x + " " + p.y + " ";
            }

            if (currentMode === MODE_DRAW) {
                // set stroke since still drawing
                polygonElem.setAttributeNS(null, "fill", "none");
                polygonElem.setAttributeNS(null, "stroke", "black");
                polygonElem.setAttributeNS(null, "stroke-width", zoomCorrection);
            } else {
                // close and fill since done drawing
                polygonElem.setAttributeNS(null, "stroke", "none");
                polygonElem.setAttributeNS(null, "fill", "rgb(200,200,200)");
                dataStr += "Z";
            }

            polygonElem.setAttributeNS(null, "d", dataStr);

            // calculate and draw centroid
            var centroid = polyCentroid(polygon);
            centroidElem.setAttributeNS(null, "cx", centroid.x);
            centroidElem.setAttributeNS(null, "cy", centroid.y);

            // calculate and display area if done drawing
            if (currentMode !== MODE_DRAW) {
                var area = Math.abs(polySignedArea(polygon));
                document.getElementById("area-display").textContent = area.toFixed(2);
            }

            if (baseLeftCorner && baseRightCorner) {
                var baseWidth = pointDist(baseLeftCorner, baseRightCorner);
                document.getElementById("base-width-display").textContent = baseWidth.toFixed(2);

                var rightVec = normalDiff(baseLeftCorner, baseRightCorner);
                var downVec = {x: -rightVec.y, y: rightVec.x};

                var leftMinusCog = pointSub(baseLeftCorner, centroid);
                var rightMinusCog = pointSub(baseRightCorner, centroid);

                var centroidHeight = vecDot(downVec, leftMinusCog);
                assert(Math.abs(vecDot(downVec, rightMinusCog) - centroidHeight) < 1e-10); // shouldn't matter which corner

                var leftHalfWidth = -vecDot(leftMinusCog, rightVec);
                var rightHalfWidth = vecDot(rightMinusCog, rightVec);
                assert(Math.abs(leftHalfWidth-rightHalfWidth)/(0.5*(leftHalfWidth+rightHalfWidth)) < 0.01); // half-widths should be very close to each other

                var critAngle = Math.atan2(Math.min(leftHalfWidth, rightHalfWidth), centroidHeight)*180.0/Math.PI;
                document.getElementById("crit-angle-display").textContent = critAngle.toFixed(2) + "\u00B0";
            } else {
                document.getElementById("base-width-display").textContent = "";
                document.getElementById("crit-angle-display").textContent = "";
            }
        } else {
            polyContainerElem.removeChild(polygonElem);
            polygonElem = null;

            polyContainerElem.removeChild(centroidElem);
            centroidElem = null;

            if (vertexHighlightElem) {
                polyContainerElem.removeChild(vertexHighlightElem);
            }

            document.getElementById("area-display").textContent = "";
            document.getElementById("base-width-display").textContent = "";
            document.getElementById("crit-angle-display").textContent = "";
        }

        // redraw highlights each time. not most efficient, but more manageable
        removeAllChildren(highlightContainerElem);

        // iterate all segments
        if (polygon && (polygon.length >= 2)) {
            for (var i = 0; i < polygon.length; i++) {
                var s0 = polygon[i];
                var s1 = polygon[(i+1)%polygon.length];
                var color = null;

                if (selectedSegments.hasOwnProperty(i)) {
                    color = "blue";
                } else if (outputSegments.hasOwnProperty(i)) {
                    color = "purple";
                } else {
                    for (var j = 0; j < inputSegmentsList.length; j++) {
                        if (inputSegmentsList[j].hasOwnProperty(i)) {
                            color = "yellow";
                        }
                    }
                }

                if (color) {
                    highlightContainerElem.appendChild(svgElem("line", {x1: s0.x, y1: s0.y, x2: s1.x, y2: s1.y, stroke: color, "stroke-width": 2.0*zoomCorrection}));
                }
            }
        }
    }

    // null to highlight no vertex
    function updatedHighlightedVertex() {
        if (highlightedVertexIndex === null) {
            if (vertexHighlightElem) {
                polyContainerElem.removeChild(vertexHighlightElem);
                vertexHighlightElem = null;
            }
        } else {
            if (!vertexHighlightElem) {
                vertexHighlightElem = svgElem("circle", {fill: "green", stroke: "none", r: "1"});
                polyContainerElem.appendChild(vertexHighlightElem);
            }

            var ph = polygon[highlightedVertexIndex];
            vertexHighlightElem.setAttributeNS(null, "cx", ph.x);
            vertexHighlightElem.setAttributeNS(null, "cy", ph.y);
        }
    }

    function updateSelectBox() {
        if (currentMode === MODE_SELECT_BOX) {
            if (!selectBoxElem) {
                selectBoxElem = svgElem("rect", {fill: "none", stroke: "orange", "stroke-width": "1", "stroke-dasharray": "5, 2"});
                selectBoxContainerElem.appendChild(selectBoxElem);
            }

            var start = pageToElemCoords(selectBoxStart, selectBoxContainerElem);
            var end = pageToElemCoords(selectBoxEnd, selectBoxContainerElem);

            var x0 = Math.min(start.x, end.x);
            var x1 = Math.max(start.x, end.x);
            var y0 = Math.min(start.y, end.y);
            var y1 = Math.max(start.y, end.y);

            selectBoxElem.setAttributeNS(null, "x", x0);
            selectBoxElem.setAttributeNS(null, "y", y0);
            selectBoxElem.setAttributeNS(null, "width", x1 - x0);
            selectBoxElem.setAttributeNS(null, "height", y1 - y0);
        } else {
            selectBoxContainerElem.removeChild(selectBoxElem);
            selectBoxElem = null;
        }
    }

    function applySelectBox() {
        assert(selectBoxStart && selectBoxEnd);

        var start = pageToElemCoords(selectBoxStart, polyContainerElem);
        var end = pageToElemCoords(selectBoxEnd, polyContainerElem);

        var x0 = Math.min(start.x, end.x);
        var x1 = Math.max(start.x, end.x);
        var y0 = Math.min(start.y, end.y);
        var y1 = Math.max(start.y, end.y);

        selectedSegments = {}; // should already be cleared I think
        for (var i = 0; i < polygon.length; i++) {
            var p = polygon[i];
            if ((p.x >= x0) && (p.x < x1) && (p.y >= y0) && (p.y < y1)) {
                selectedSegments[i] = null;
                selectedSegments[(i-1+polygon.length)%polygon.length] = null;
            }
        }
    }

    function importSVG(fileData) {
        var pathDataMatch = /<path d="([^"]*)"/.exec(fileData);
        assert(pathDataMatch);

        var pathData = pathDataMatch[1];

        var commandRegexp = /([A-Za-z])\s*([-0-9.,\s]*)/g; // can't be a literal inside while condition
        var paramRegexp = /-?[0-9.]+/g;
        var result;

        var currentPoint;
        var subpathStart;
        var importedPoly = [];
        while ((result = commandRegexp.exec(pathData)) !== null) {
            var commandLetter = result[1];
            var paramResult;
            var params = [];
            while ((paramResult = paramRegexp.exec(result[2])) !== null) {
                params.push(+paramResult[0]);
            }

            if (commandLetter === 'M') {
                assert(params.length === 2);
                currentPoint = {x: params[0], y: params[1]};
                subpathStart = {x: params[0], y: params[1]};
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if (commandLetter === 'l') {
                assert(params.length === 2);
                currentPoint.x += params[0];
                currentPoint.y += params[1];
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if ((commandLetter === 'c') || (commandLetter === 'C')) {
                assert(params.length === 6);
                if (commandLetter === 'c') {
                    currentPoint.x += params[4];
                    currentPoint.y += params[5];
                } else if (commandLetter === 'C') {
                    currentPoint.x = params[4];
                    currentPoint.y = params[5];
                } else {
                    assert(false);
                }
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if (commandLetter === 's') {
                assert(params.length === 4);
                currentPoint.x += params[2];
                currentPoint.y += params[3];
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if ((commandLetter === 'z') || (commandLetter === 'Z')) {
                assert(params.length === 0);
            } else {
                console.log("unhandled command", commandLetter);
                assert(false);
            }
        }

        var centroid = polyCentroid(importedPoly);
        for (var i = 0; i < importedPoly.length; i++) {
            importedPoly[i].x -= centroid.x;
            importedPoly[i].y -= centroid.y;
        }

        polygon = importedPoly;
        baseLeftCorner = baseRightCorner = null;
        updatePolygonElem();

        // clear selection and input/output regions
        selectedSegments = {};
        outputSegments = {};
        inputSegmentsList = [];
    }

    function doBalance() {
        var outputDepth = +(document.getElementById("output-depth").value);

        var downVec = {x: Math.sin(rotation), y: Math.cos(rotation)};
        var iterationCount = 0;
        var MAX_ITERATIONS = 50;
        while (true) {
            console.log("downVec", downVec);

            var upVec = {x: -downVec.x, y: -downVec.y};

            var cutResult = cutPolygon(polygon, outputSegments, upVec, outputDepth);

            // find center point of new base
            var baseCenter = {x: 0.5*(cutResult.leftmostIntersection.x + cutResult.rightmostIntersection.x), y: 0.5*(cutResult.leftmostIntersection.y + cutResult.rightmostIntersection.y)};

            // change down vector to have base center directly under new centroid
            var centroid = polyCentroid(cutResult.cutPoly);
            var newDownVec = normalDiff(centroid, baseCenter);
            var downDot = vecDot(downVec, newDownVec);

            // is the newDownVec basically the same as downVec?
            if (downDot > (1.0 - 1e-15)) {
                // converged sufficiently
                break;
            }

            downVec = newDownVec;

            iterationCount++;
            if (iterationCount > MAX_ITERATIONS) {
                assert(false); // too many iterations, something not right
            }
        }

        // clear selection
        selectedSegments = {};
        outputSegments = {};
        inputSegmentsList = [];

        polygon = cutResult.cutPoly;
        baseLeftCorner = cutResult.leftmostIntersection;
        baseRightCorner = cutResult.rightmostIntersection;
        updatePolygonElem();

        rotation = 0.5*Math.PI - Math.atan2(downVec.y, downVec.x);
        updateViewTransforms();
    }

    interactionElem.addEventListener("contextmenu", function (e) {
        e.preventDefault();
        if (currentMode == MODE_DRAW) {
            currentMode = MODE_NOTHING;
            polygon.pop();
            updatePolygonElem();
        }
    }, false);

    interactionElem.addEventListener("mousedown", function (e) {
        if (currentMode === MODE_NOTHING) {
            if (e.button === 0) {
                if (e.shiftKey) {
                    currentMode = MODE_SELECT_BOX;
                    selectBoxStart = selectBoxEnd = {x: e.pageX, y: e.pageY};
                    updateSelectBox();

                    selectedSegments = {};
                    // TODO: updatePolygonElem()?
                } else {
                    if (polygon) {
                        // enter drag mode
                        currentMode = MODE_PAN;
                        dragPrev = {x: e.pageX, y: e.pageY};
                    } else {
                        currentMode = MODE_DRAW;
                        polygon = [];

                        var p = eventToElemCoords(e, polyContainerElem);
                        polygon.push(p);
                        polygon.push(p); // push again, so we have two points
                        updatePolygonElem();
                    }
                }
            }
        } else if (currentMode === MODE_DRAW) {
            if (e.button === 0) {
                // add another point
                var p = eventToElemCoords(e, polyContainerElem);
                polygon.push(p);
                updatePolygonElem();
            }
        }
    }, false);

    document.addEventListener("mouseup", function (e) {
        if (currentMode === MODE_PAN) {
            currentMode = MODE_NOTHING;
        } else if (currentMode === MODE_ROTATE) {
            currentMode = MODE_NOTHING;
        } else if (currentMode === MODE_SELECT_BOX) {
            applySelectBox();
            updatePolygonElem();

            currentMode = MODE_NOTHING;
            selectBoxStart = selectBoxEnd = null;
            updateSelectBox();
        }
    }, false);

    document.addEventListener("mousemove", function (e) {
        var cur = eventToElemCoords(e, polyContainerElem);
        document.getElementById("cursor-display").textContent = cur.x.toFixed(4) + ", " + cur.y.toFixed(4);

        if (currentMode === MODE_NOTHING) {
            if (polygon) {
                var cur = eventToElemCoords(e, polyContainerElem);
                var radius = 10.0;
                highlightedVertexIndex = nearestVertex(polygon, cur, radius);
                updatedHighlightedVertex();
            }
        } else if (currentMode === MODE_DRAW) {
            e.preventDefault();
            var p = eventToElemCoords(e, polyContainerElem);
            polygon[polygon.length-1] = p;
            updatePolygonElem();
        } else if (currentMode === MODE_PAN) {
            e.preventDefault();
            var prev = pageToElemCoords(dragPrev, viewTransformGroupElem);
            var cur = eventToElemCoords(e, viewTransformGroupElem);

            var dx = cur.x - prev.x;
            var dy = cur.y - prev.y;
            panSumX += dx;
            panSumY += dy;
            updateViewTransforms();

            dragPrev = {x: e.pageX, y: e.pageY};
        } else if (currentMode === MODE_ROTATE) {
            e.preventDefault();
            var dy = e.pageY - dragPrev.y;
            rotation += 0.01*dy;

            updateViewTransforms();

            dragPrev = {x: e.pageX, y: e.pageY};
        } else if (currentMode === MODE_SELECT_BOX) {
            e.preventDefault();
            selectBoxEnd = {x: e.pageX, y: e.pageY};
            updateSelectBox();
        }
        lastMousePos = {x: e.pageX, y: e.pageY};
    }, false);

    interactionElem.addEventListener("mousewheel", function(e) {
        if (currentMode === MODE_NOTHING) {
            zoomLog += -0.001*e.wheelDelta;
            updateViewTransforms();
        }
    }, false);

    document.getElementById("clear-button").addEventListener("click", function(e) {
        currentMode = MODE_NOTHING;
        polygon = null;
        baseLeftCorner = baseRightCorner = null;
        updatePolygonElem();

        // clear selection and input/output regions
        selectedSegments = {};
        outputSegments = {};
        inputSegmentsList = [];
    }, false);

    document.getElementById("set-output-button").addEventListener("click", function(e) {
        outputSegments = {};
        mergeUpdate(outputSegments, selectedSegments);

        // clear selection
        selectedSegments = {};

        updatePolygonElem();
    }, false);

    document.getElementById("add-input-button").addEventListener("click", function(e) {
        if (!isEmpty(selectedSegments)) {
            var inp = {};
            mergeUpdate(inp, selectedSegments);
            inputSegmentsList.push(inp);

            // clear selection
            selectedSegments = {};

            updatePolygonElem();
        }
    }, false);

    document.getElementById("balance-button").addEventListener("click", function(e) {
        doBalance();
    }, false);

    document.getElementById("import-file-button").addEventListener("click", function(e) {
        var fileInput = document.getElementById("import-file-input");
        if (fileInput.files.length === 1) {
            var reader = new FileReader();
            reader.onload = function(e) {
                importSVG(e.target.result);
            }
            reader.readAsText(fileInput.files[0]);
        }
    }, false);

    document.getElementById("rotate-pad").addEventListener("mousedown", function(e) {
        e.preventDefault();
        if (currentMode === MODE_NOTHING) {
            currentMode = MODE_ROTATE;
            dragPrev = {x: e.pageX, y: e.pageY};
        }
    }, false);

    // toggling control panel
    var controlPanelElem = document.getElementById("control-panel");
    var controlPanelShown = true;
    document.addEventListener("keydown", function(e) {
        if (e.keyCode === 27) {
            if (controlPanelShown) {
                controlPanelElem.setAttribute("style", "display:none");
            } else {
                controlPanelElem.setAttribute("style", "display:block");
            }
            controlPanelShown = !controlPanelShown;
        }
    }, false);

    document.addEventListener("keyup", function(e) {
    }, false);

}, false);
</script>
</body>
</html>
