<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Cog</title>
<meta name="viewport" content="width=device-width">
<style type="text/css">
body {
    overflow: hidden;
    font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
}

#main {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
}

#control-panel {
    display: block;
    position: fixed;
    top: 0;
    right: 0;
    padding: 5px;
    box-sizing: border-box;
    background-color: rgba(100,100,100,0.8);
}
</style>
</head>
<body>
<div id="main"></div>
<div id="control-panel">
    <div><button id="clear-button">Clear</button> <button id="balance-button">Balance</button></div>
    <div><input name="import-file-input" type="file" id="import-file-input"><button id="import-file-button">Import</button></div>
    <div><label>Area: <span id="area-display"></span></label></div>
</div>
<script>
"use strict";

function assert(test) {
    if (!test) {
        throw "assertion fail";
    }
}

var SVGNS = "http://www.w3.org/2000/svg";

function svgElem(name, attrs) {
    var elem = document.createElementNS(SVGNS, name);

    if (attrs) {
        for (var k in attrs) {
            if (attrs.hasOwnProperty(k)) {
                elem.setAttributeNS(null, k, attrs[k]);
            }
        }
    }

    return elem;
}

function removeAllChildren(elem) {
    while (elem.hasChildNodes()) {
        elem.removeChild(elem.childNodes[0]);
    }
}

function pointCopy(p) {
    return {x: p.x, y: p.y};
}

function pointSub(a, b) {
    return {x: a.x - b.x, y: a.y - b.y};
}

function vecDot(a, b) {
    return a.x*b.x + a.y*b.y;
}

function pointDist(a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
}

function pointDistSqr(a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return dx*dx + dy*dy;
}

function normalDiff(from, to) {
    var dx = to.x - from.x;
    var dy = to.y - from.y;
    var invmag = 1.0/Math.sqrt(dx*dx + dy*dy);
    return {x: invmag*dx, y: invmag*dy};
}

function polySignedArea(poly) {
    var sum = 0;
    for (var i = 0; i < poly.length; i++) {
        var i1 = (i+1) % poly.length;
        sum += poly[i].x*poly[i1].y - poly[i1].x*poly[i].y;
    }
    return 0.5*sum;
}

// from http://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon
function polyCentroid(poly) {
    var area = polySignedArea(poly);
    if (area === 0) { // TODO: could check against an epsilon instead
        var xsum = 0, ysum = 0;
        for (var i = 0; i < poly.length; i++) {
            xsum += poly[i].x;
            ysum += poly[i].y;
        }
        var factor = 1.0/poly.length;
        return {x: factor*xsum, y: factor*ysum};
    }

    var xsum = 0, ysum = 0;

    for (var i = 0; i < poly.length; i++) {
        var i1 = (i+1) % poly.length;
        var sub = poly[i].x*poly[i1].y - poly[i1].x*poly[i].y;
        xsum += sub*(poly[i].x + poly[i1].x);
        ysum += sub*(poly[i].y + poly[i1].y);
    }

    var factor = 1.0/(6*area);
    return {x: factor*xsum, y: factor*ysum};
}

// return index of polygon vertex that is nearest to point p, within given radius. null if no vertex within radius
function nearestVertex(poly, p, radius) {
    var radSqr = radius*radius;
    var nearestIndex = null;
    var nearestDistSqr;

    for (var i = 0; i < poly.length; i++) {
        var distSqr = pointDistSqr(poly[i], p);
        if ((distSqr <= radius) && ((nearestDistSqr === undefined) || (distSqr < nearestDistSqr))) {
            nearestIndex = i;
            nearestDistSqr = distSqr;
        }
    }

    return nearestIndex;
}

document.addEventListener("DOMContentLoaded", function() {
    var rootSVGElem = svgElem("svg", {version: "1.1"});

    var bg = svgElem("rect", {x: "0", y: "0", width: "100%", height: "100%", fill: "rgb(100,100,100)", stroke: "none"});
    rootSVGElem.appendChild(bg);

    var innerSVGElem = svgElem("svg", {version: "1.1", viewBox: "-60 -60 120 120"});
    rootSVGElem.appendChild(innerSVGElem);

    var zoomGroupElem = svgElem("g");
    innerSVGElem.appendChild(zoomGroupElem);

    var polyContainerElem = zoomGroupElem;

    // polygon
    var polygon = null; // array of objects with x and y attrs
    var polygonElem = null;
    var centroidElem = null;

    var highlightedVertexIndex = null;
    var vertexHighlightElem = null;

    document.getElementById("main").appendChild(rootSVGElem);

    // interaction
    var MODE_NOTHING = 0;
    var MODE_DRAW = 1;
    var MODE_PAN = 2;
    var MODE_ZOOM = 3;
    var MODE_MARK_OUTPUT = 4;
    var currentMode = MODE_NOTHING;

    var lastMousePos;
    var interactionElem = rootSVGElem;
    var dragPrev = null;
    var panSumX = 0, panSumY = 0;
    var zoomSumY = 0;
    var rotation = 0;

    var outputCenter = null;
    var outputRadius = 0;
    var outputRegionElem = null;

    function pageToElemCoords(pageCoords, elem) {
        var m = elem.getScreenCTM();
        var p = rootSVGElem.createSVGPoint();
        p.x = pageCoords.x;
        p.y = pageCoords.y;
        p = p.matrixTransform(m.inverse());
        return {x: p.x, y: p.y};
    }

    function eventToElemCoords(event, elem) {
        // return coords of event in coord space of element
        var pageCoords = {x: event.pageX, y: event.pageY};
        return pageToElemCoords(pageCoords, elem);
    }

    function setPanZoom(zoom) {
        var zoom = Math.exp(-0.01*zoomSumY);
        var rotDegrees = 180*rotation/Math.PI;
        zoomGroupElem.setAttributeNS(null, "transform", "rotate(" + rotDegrees  + ") scale(" + zoom + ") translate(" + panSumX + "," + panSumY + ")");
    }

    function updatePolygonElem() {
        if (polygon) {
            if (!polygonElem) {
                polygonElem = svgElem("path", {fill: "none", stroke: "black", "stroke-width": "0.1"});
                polyContainerElem.appendChild(polygonElem);

                centroidElem = svgElem("circle", {fill: "red", r: "1"});
                polyContainerElem.appendChild(centroidElem);
            }
            var dataStr = "";
            dataStr += "M " + polygon[0].x + " " + polygon[0].y + " ";
            for (var i = 1; i < polygon.length; i++) {
                var p = polygon[i];
                dataStr += "L " +  p.x + " " + p.y + " ";
            }

            // close and fill if done drawing
            if (currentMode !== MODE_DRAW) {
                polygonElem.setAttributeNS(null, "fill", "rgb(200,200,200)");
                dataStr += "Z";
            }

            polygonElem.setAttributeNS(null, "d", dataStr);

            // calculate and draw centroid
            var centroid = polyCentroid(polygon);
            centroidElem.setAttributeNS(null, "cx", centroid.x);
            centroidElem.setAttributeNS(null, "cy", centroid.y);

            // calculate and display area if done drawing
            if (currentMode !== MODE_DRAW) {
                var area = Math.abs(polySignedArea(polygon));
                document.getElementById("area-display").textContent = area;
            }
        } else {
            polyContainerElem.removeChild(polygonElem);
            polygonElem = null;

            polyContainerElem.removeChild(centroidElem);
            centroidElem = null;

            if (vertexHighlightElem) {
                polyContainerElem.removeChild(vertexHighlightElem);
            }

            document.getElementById("area-display").textContent = "";
        }
    }

    // null to highlight no vertex
    function updatedHighlightedVertex() {
        if (highlightedVertexIndex === null) {
            if (vertexHighlightElem) {
                polyContainerElem.removeChild(vertexHighlightElem);
                vertexHighlightElem = null;
            }
        } else {
            if (!vertexHighlightElem) {
                vertexHighlightElem = svgElem("circle", {fill: "green", stroke: "none", r: "1"});
                polyContainerElem.appendChild(vertexHighlightElem);
            }

            var ph = polygon[highlightedVertexIndex];
            vertexHighlightElem.setAttributeNS(null, "cx", ph.x);
            vertexHighlightElem.setAttributeNS(null, "cy", ph.y);
        }
    }

    function updateOutputRegion() {
        if (outputCenter === null) {
            if (outputRegionElem) {
                polyContainerElem.removeChild(outputRegionElem);
                outputRegionElem = null;
            }
        } else {
            if (!outputRegionElem) {
                outputRegionElem = svgElem("circle", {fill: "none", stroke: "yellow", "stroke-width": "0.1"});
                polyContainerElem.appendChild(outputRegionElem);
            }

            outputRegionElem.setAttributeNS(null, "cx", outputCenter.x);
            outputRegionElem.setAttributeNS(null, "cy", outputCenter.y);
            outputRegionElem.setAttributeNS(null, "r", outputRadius);
        }
    }

    function importSVG(fileData) {
        var pathDataMatch = /<path d="([^"]*)"/.exec(fileData);
        assert(pathDataMatch);

        var pathData = pathDataMatch[1];

        var commandRegexp = /([A-Za-z])\s*([-0-9.,\s]*)/g; // can't be a literal inside while condition
        var paramRegexp = /-?[0-9.]+/g;
        var result;

        var currentPoint;
        var subpathStart;
        var importedPoly = [];
        while ((result = commandRegexp.exec(pathData)) !== null) {
            var commandLetter = result[1];
            var paramResult;
            var params = [];
            while ((paramResult = paramRegexp.exec(result[2])) !== null) {
                params.push(+paramResult[0]);
            }

            if (commandLetter === 'M') {
                assert(params.length === 2);
                currentPoint = {x: params[0], y: params[1]};
                subpathStart = {x: params[0], y: params[1]};
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if (commandLetter === 'l') {
                assert(params.length === 2);
                currentPoint.x += params[0];
                currentPoint.y += params[1];
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if ((commandLetter === 'c') || (commandLetter === 'C')) {
                assert(params.length === 6);
                if (commandLetter === 'c') {
                    currentPoint.x += params[4];
                    currentPoint.y += params[5];
                } else if (commandLetter === 'C') {
                    currentPoint.x = params[4];
                    currentPoint.y = params[5];
                } else {
                    assert(false);
                }
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if (commandLetter === 's') {
                assert(params.length === 4);
                currentPoint.x += params[2];
                currentPoint.y += params[3];
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if ((commandLetter === 'z') || (commandLetter === 'Z')) {
                assert(params.length === 0);
            } else {
                console.log("unhandled command", commandLetter);
                assert(false);
            }
        }

        var centroid = polyCentroid(importedPoly);
        for (var i = 0; i < importedPoly.length; i++) {
            importedPoly[i].x -= centroid.x;
            importedPoly[i].y -= centroid.y;
        }

        polygon = importedPoly;
        updatePolygonElem();

        outputCenter = null;
        outputRadius = 0;
        updateOutputRegion();
    }

    function doBalance() {
        if (outputCenter === null) {
            return;
        }

        // figure out what segments are in output region. segment index i is formed by vertex i and i+1
        var segmentInOutput = [];
        for (var i = 0; i < polygon.length; i++) {
            segmentInOutput.push(false);
        }
        for (var i = 0; i < polygon.length; i++) {
            if (pointDistSqr(polygon[i], outputCenter) < outputRadius*outputRadius) {
                segmentInOutput[i] = true;
                segmentInOutput[(i-1+polygon.length)%polygon.length] = true;
            }
        }

        // compute initial down vector by using furthest point from centroid within output region
        // TODO: this should probably be changed to use selected segments, not output region circle
        var centroid = polyCentroid(polygon);
        var maxDistSqr;
        var maxDistIdx;
        for (var i = 0; i < polygon.length; i++) {
            if (pointDistSqr(polygon[i], outputCenter) < outputRadius*outputRadius) {
                var dsqr = pointDistSqr(polygon[i], centroid);
                if ((maxDistSqr === undefined) || (dsqr > maxDistSqr)) {
                    maxDistSqr = dsqr;
                    maxDistIdx = i;
                }
            }
        }

        // find a segment not in output region to start with, any is fine
        var startSegmentIdx;
        for (var i = 0; i < polygon.length; i++) {
            if (!segmentInOutput[i]) {
                startSegmentIdx = i;
                break;
            }
        }
        assert(startSegmentIdx !== undefined);

        var balancePoint = polygon[maxDistIdx];
        var downVec = normalDiff(centroid, balancePoint);
        var iterationCount = 0;
        while (true) {
            console.log("downVec", downVec);

            // find maximum dot product against downVec that is within cutting region
            var maxDot;
            for (var i = 0; i < polygon.length; i++) {
                if (segmentInOutput[i]) {
                    var d1 = vecDot(polygon[i], downVec);
                    if ((maxDot === undefined) || (d1 > maxDot)) {
                        maxDot = d1;
                    }

                    var d2 = vecDot(polygon[(i+1)%polygon.length], downVec);
                    if ((maxDot === undefined) || (d2 > maxDot)) {
                        maxDot = d2;
                    }
                }
            }

            // figure out cutting line
            var cutDepth = 10.0;
            var cutA = downVec.x;
            var cutB = downVec.y;
            var cutC = -maxDot + cutDepth;

            // do the cut
            var segIdx = startSegmentIdx;
            var cutPoly = []; // result of cutting
            var inCut = false; // are we in cut?
            var cutIntersections = []; // points where polygon crossed cut
            while (true) {
                var segStart = polygon[segIdx];
                var segEnd = polygon[(segIdx+1)%polygon.length];

                if (segmentInOutput[segIdx]) {
                    // TODO: test segment against cutting line
                    var segV = pointSub(segEnd, segStart);
                    var denom = cutA*segV.x + cutB*segV.y;
                    assert(denom !== 0);
                    var t = -(cutA*segStart.x + cutB*segStart.y + cutC)/denom;

                    if ((t > 0) && (t <= 1)) {
                        var inter = {x: segStart.x + t*segV.x, y: segStart.y + t*segV.y};

                        cutIntersections.push(inter);

                        if (inCut) {
                            // coming out of cut back to un-cut

                            cutPoly.push(inter); // add intersection point

                            inCut = false; // no longer in cut

                            cutPoly.push(pointCopy(segEnd));
                        } else {
                            // going into cut
                            cutPoly.push(inter); // add intersection point

                            inCut = true;
                        }
                    } else {
                        // segment does not cross cutting line
                        if (inCut) {
                            // inside cut, so ignore this segment
                        } else {
                            // outside cut, so copy of segment endpoint
                            cutPoly.push(pointCopy(segEnd));
                        }
                    }
                } else {
                    assert(inCut === false); // should have come back out of cut if we aren't in output region
                    cutPoly.push(pointCopy(segEnd));
                }

                // move to next segment index, wrapping around, terminate if we went all the way around
                segIdx++;
                segIdx = segIdx % polygon.length;
                if (segIdx === startSegmentIdx) {
                    break;
                }
            }

            // now that we've cut the poly, find the extrema of the intersection points (the new base)
            assert(cutIntersections.length >= 2);
            var leftmostIntersection, rightmostIntersection;
            var leftmostDot, rightmostDot;
            var rightVec = {x: downVec.y, y: -downVec.x};
            for (var i = 0; i < cutIntersections.length; i++) {
                var dot = vecDot(rightVec, cutIntersections[i]);
                if ((rightmostDot === undefined) || (dot > rightmostDot)) {
                    rightmostIntersection = cutIntersections[i];
                    rightmostDot = dot;
                }
                if ((leftmostDot === undefined) || (dot < leftmostDot)) {
                    leftmostIntersection = cutIntersections[i];
                    leftmostDot = dot;
                }
            }

            iterationCount++;
            if (iterationCount >= 20) {
                break;
            }

            // find center point of new base
            var baseCenter = {x: 0.5*(leftmostIntersection.x + rightmostIntersection.x), y: 0.5*(leftmostIntersection.y + rightmostIntersection.y)};

            // change down vector to have base center directly under new centroid
            centroid = polyCentroid(cutPoly);
            downVec = normalDiff(centroid, baseCenter);
        }

        polygon = cutPoly;
        updatePolygonElem();
        rotation = 0.5*Math.PI - Math.atan2(downVec.y, downVec.x);
        setPanZoom();
    }

    interactionElem.addEventListener("contextmenu", function (e) {
        e.preventDefault();
        if (currentMode == MODE_DRAW) {
            currentMode = MODE_NOTHING;
            polygon.pop();
            updatePolygonElem();
        }
    }, false);

    interactionElem.addEventListener("mousedown", function (e) {
        if (currentMode === MODE_NOTHING) {
            if (e.button === 0) {
                if (polygon) {
                    // enter drag mode
                    currentMode = MODE_PAN;
                    dragPrev = {x: e.pageX, y: e.pageY};
                } else {
                    currentMode = MODE_DRAW;
                    polygon = [];

                    var p = eventToElemCoords(e, polyContainerElem);
                    polygon.push(p);
                    polygon.push(p); // push again, so we have two points
                    updatePolygonElem();
                }
            } else if (e.button === 2) {
                // right click
                currentMode = MODE_ZOOM;
                dragPrev = {x: e.pageX, y: e.pageY};
            }
        } else if (currentMode === MODE_DRAW) {
            if (e.button === 0) {
                // add another point
                var p = eventToElemCoords(e, polyContainerElem);
                polygon.push(p);
                updatePolygonElem();
            }
        }
    }, false);

    interactionElem.addEventListener("mouseup", function (e) {
        if (currentMode === MODE_PAN) {
            currentMode = MODE_NOTHING;
        } else if (currentMode === MODE_ZOOM) {
            currentMode = MODE_NOTHING;
        }
    }, false);

    interactionElem.addEventListener("mousemove", function (e) {
        if (currentMode === MODE_NOTHING) {
            if (polygon) {
                var cur = eventToElemCoords(e, polyContainerElem);
                var radius = 10.0;
                highlightedVertexIndex = nearestVertex(polygon, cur, radius);
                updatedHighlightedVertex();
            }
        } else if (currentMode === MODE_DRAW) {
            var p = eventToElemCoords(e, polyContainerElem);
            polygon[polygon.length-1] = p;
            updatePolygonElem();
        } else if (currentMode === MODE_PAN) {
            var prev = pageToElemCoords(dragPrev, polyContainerElem);
            var cur = eventToElemCoords(e, polyContainerElem);

            var dx = cur.x - prev.x;
            var dy = cur.y - prev.y;
            panSumX += dx;
            panSumY += dy;
            setPanZoom();

            dragPrev = {x: e.pageX, y: e.pageY};
        } else if (currentMode === MODE_ZOOM) {
            var dy = e.pageY - dragPrev.y;
            zoomSumY += dy;
            setPanZoom();
            dragPrev = {x: e.pageX, y: e.pageY};
        } else if (currentMode === MODE_MARK_OUTPUT) {
            var p = eventToElemCoords(e, polyContainerElem);
            outputRadius = pointDist(p, outputCenter);
            updateOutputRegion();
        }
        lastMousePos = {x: e.pageX, y: e.pageY};
    }, false);

    document.getElementById("clear-button").addEventListener("click", function(e) {
        currentMode = MODE_NOTHING;
        polygon = null;
        updatePolygonElem();

        outputCenter = null;
        outputRadius = 0;
        updateOutputRegion();
    }, false);

    document.getElementById("balance-button").addEventListener("click", function(e) {
        doBalance();
    }, false);

    document.getElementById("import-file-button").addEventListener("click", function(e) {
        var fileInput = document.getElementById("import-file-input");
        if (fileInput.files.length === 1) {
            var reader = new FileReader();
            reader.onload = function(e) {
                importSVG(e.target.result);
            }
            reader.readAsText(fileInput.files[0]);
        }
    }, false);

    // toggling control panel
    var controlPanelElem = document.getElementById("control-panel");
    var controlPanelShown = true;
    document.addEventListener("keydown", function(e) {
        if (e.keyCode === 27) {
            if (controlPanelShown) {
                controlPanelElem.setAttribute("style", "display:none");
            } else {
                controlPanelElem.setAttribute("style", "display:block");
            }
            controlPanelShown = !controlPanelShown;
        } else if (e.keyCode === 'O'.charCodeAt(0)) {
            if (currentMode === MODE_NOTHING) {
                // mark output region
                currentMode = MODE_MARK_OUTPUT;
                outputCenter = pageToElemCoords(lastMousePos, polyContainerElem);
                outputRadius = 0;
            }
        }
    }, false);

    document.addEventListener("keyup", function(e) {
        if (e.keyCode === 'O'.charCodeAt(0)) {
            if (currentMode === MODE_MARK_OUTPUT) {
                currentMode = MODE_NOTHING;
            }
        }
    }, false);

}, false);
</script>
</body>
</html>
