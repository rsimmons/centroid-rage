<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Cog</title>
<meta name="viewport" content="width=device-width">
<style type="text/css">
body {
    overflow: hidden;
    font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
}

#main {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
}

#control-panel {
    display: block;
    position: fixed;
    top: 0;
    right: 0;
    padding: 5px;
    box-sizing: border-box;
    background-color: rgba(100,100,100,0.8);
}
</style>
</head>
<body>
<div id="main"></div>
<div id="control-panel">
    <div><button id="clear-button">Clear</button></div>
    <div><input name="import-file-input" type="file" id="import-file-input"><button id="import-file-button">Import</button></div>
    <div><label>Area: <span id="area-display"></span></label></div>
</div>
<script>
"use strict";

function assert(test) {
    if (!test) {
        throw "assertion fail";
    }
}

var SVGNS = "http://www.w3.org/2000/svg";

function svgElem(name, attrs) {
    var elem = document.createElementNS(SVGNS, name);

    if (attrs) {
        for (var k in attrs) {
            if (attrs.hasOwnProperty(k)) {
                elem.setAttributeNS(null, k, attrs[k]);
            }
        }
    }

    return elem;
}

function removeAllChildren(elem) {
    while (elem.hasChildNodes()) {
        elem.removeChild(elem.childNodes[0]);
    }
}

function pointDist(a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
}

function polySignedArea(poly) {
    var sum = 0;
    for (var i = 0; i < poly.length; i++) {
        var i1 = (i+1) % poly.length;
        sum += poly[i].x*poly[i1].y - poly[i1].x*poly[i].y;
    }
    return 0.5*sum;
}

// from http://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon
function polyCentroid(poly) {
    var area = polySignedArea(poly);
    if (area === 0) { // TODO: could check against an epsilon instead
        var xsum = 0, ysum = 0;
        for (var i = 0; i < poly.length; i++) {
            xsum += poly[i].x;
            ysum += poly[i].y;
        }
        var factor = 1.0/poly.length;
        return {x: factor*xsum, y: factor*ysum};
    }

    var xsum = 0, ysum = 0;

    for (var i = 0; i < poly.length; i++) {
        var i1 = (i+1) % poly.length;
        var sub = poly[i].x*poly[i1].y - poly[i1].x*poly[i].y;
        xsum += sub*(poly[i].x + poly[i1].x);
        ysum += sub*(poly[i].y + poly[i1].y);
    }

    var factor = 1.0/(6*area);
    return {x: factor*xsum, y: factor*ysum};
}

// return index of polygon vertex that is nearest to point p, within given radius. null if no vertex within radius
function nearestVertex(poly, p, radius) {
    var radSqr = radius*radius;
    var nearestIndex = null;
    var nearestDistSqr;

    for (var i = 0; i < poly.length; i++) {
        var q = poly[i];
        var dx = q.x - p.x;
        var dy = q.y - p.y;
        var distSqr = dx*dx + dy*dy;
        if ((distSqr <= radius) && ((nearestDistSqr === undefined) || (distSqr < nearestDistSqr))) {
            nearestIndex = i;
            nearestDistSqr = distSqr;
        }
    }

    return nearestIndex;
}

document.addEventListener("DOMContentLoaded", function() {
    var rootSVGElem = svgElem("svg", {version: "1.1"});

    var bg = svgElem("rect", {x: "0", y: "0", width: "100%", height: "100%", fill: "rgb(100,100,100)", stroke: "none"});
    rootSVGElem.appendChild(bg);

    var innerSVGElem = svgElem("svg", {version: "1.1", viewBox: "-60 -60 120 120"});
    rootSVGElem.appendChild(innerSVGElem);

    var zoomGroupElem = svgElem("g");
    innerSVGElem.appendChild(zoomGroupElem);

    var polyContainerElem = zoomGroupElem;

    // polygon
    var polygon = null; // array of objects with x and y attrs
    var polygonElem = null;
    var centroidElem = null;

    var highlightedVertexIndex = null;
    var vertexHighlightElem = null;

    document.getElementById("main").appendChild(rootSVGElem);

    // interaction
    var MODE_NOTHING = 0;
    var MODE_DRAW = 1;
    var MODE_PAN = 2;
    var MODE_ZOOM = 3;
    var MODE_MARK_OUTPUT = 4;
    var currentMode = MODE_NOTHING;

    var lastMousePos;
    var interactionElem = rootSVGElem;
    var dragPrev = null;
    var panSumX = 0, panSumY = 0;
    var zoomSumY = 0;
    var rotation = 0;

    var outputCenter = null;
    var outputRadius = 0;
    var outputRegionElem = null;

    function pageToElemCoords(pageCoords, elem) {
        var m = elem.getScreenCTM();
        var p = rootSVGElem.createSVGPoint();
        p.x = pageCoords.x;
        p.y = pageCoords.y;
        p = p.matrixTransform(m.inverse());
        return {x: p.x, y: p.y};
    }

    function eventToElemCoords(event, elem) {
        // return coords of event in coord space of element
        var pageCoords = {x: event.pageX, y: event.pageY};
        return pageToElemCoords(pageCoords, elem);
    }

    function setPanZoom(zoom) {
        var zoom = Math.exp(-0.01*zoomSumY);
        var rotDegrees = 180*rotation/Math.PI;
        zoomGroupElem.setAttributeNS(null, "transform", "rotate(" + rotDegrees  + ") scale(" + zoom + ") translate(" + panSumX + "," + panSumY + ")");
    }

    function updatePolygonElem() {
        if (polygon) {
            if (!polygonElem) {
                polygonElem = svgElem("path", {fill: "none", stroke: "black", "stroke-width": "0.1"});
                polyContainerElem.appendChild(polygonElem);

                centroidElem = svgElem("circle", {fill: "red", r: "1"});
                polyContainerElem.appendChild(centroidElem);
            }
            var dataStr = "";
            dataStr += "M " + polygon[0].x + " " + polygon[0].y + " ";
            for (var i = 1; i < polygon.length; i++) {
                var p = polygon[i];
                dataStr += "L " +  p.x + " " + p.y + " ";
            }

            // close and fill if done drawing
            if (currentMode !== MODE_DRAW) {
                polygonElem.setAttributeNS(null, "fill", "rgb(200,200,200)");
                dataStr += "Z";
            }

            polygonElem.setAttributeNS(null, "d", dataStr);

            // calculate and draw centroid
            var centroid = polyCentroid(polygon);
            centroidElem.setAttributeNS(null, "cx", centroid.x);
            centroidElem.setAttributeNS(null, "cy", centroid.y);

            // calculate and display area if done drawing
            if (currentMode !== MODE_DRAW) {
                var area = Math.abs(polySignedArea(polygon));
                document.getElementById("area-display").textContent = area;
            }
        } else {
            polyContainerElem.removeChild(polygonElem);
            polygonElem = null;

            polyContainerElem.removeChild(centroidElem);
            centroidElem = null;

            if (vertexHighlightElem) {
                polyContainerElem.removeChild(vertexHighlightElem);
            }

            document.getElementById("area-display").textContent = "";
        }
    }

    // null to highlight no vertex
    function updatedHighlightedVertex() {
        if (highlightedVertexIndex === null) {
            if (vertexHighlightElem) {
                polyContainerElem.removeChild(vertexHighlightElem);
                vertexHighlightElem = null;
            }
        } else {
            if (!vertexHighlightElem) {
                vertexHighlightElem = svgElem("circle", {fill: "green", stroke: "none", r: "1"});
                polyContainerElem.appendChild(vertexHighlightElem);
            }

            var ph = polygon[highlightedVertexIndex];
            vertexHighlightElem.setAttributeNS(null, "cx", ph.x);
            vertexHighlightElem.setAttributeNS(null, "cy", ph.y);
        }
    }

    function updateOutputRegion() {
        if (outputCenter === null) {
            if (outputRegionElem) {
                polyContainerElem.removeChild(outputRegionElem);
                outputRegionElem = null;
            }
        } else {
            if (!outputRegionElem) {
                outputRegionElem = svgElem("circle", {fill: "none", stroke: "yellow", "stroke-width": "0.1"});
                polyContainerElem.appendChild(outputRegionElem);
            }

            outputRegionElem.setAttributeNS(null, "cx", outputCenter.x);
            outputRegionElem.setAttributeNS(null, "cy", outputCenter.y);
            outputRegionElem.setAttributeNS(null, "r", outputRadius);
        }
    }

    function importSVG(fileData) {
        var pathDataMatch = /<path d="([^"]*)"/.exec(fileData);
        assert(pathDataMatch);

        var pathData = pathDataMatch[1];

        var commandRegexp = /([A-Za-z])\s*([-0-9.,\s]*)/g; // can't be a literal inside while condition
        var paramRegexp = /-?[0-9.]+/g;
        var result;

        var currentPoint;
        var subpathStart;
        var importedPoly = [];
        while ((result = commandRegexp.exec(pathData)) !== null) {
            var commandLetter = result[1];
            var paramResult;
            var params = [];
            while ((paramResult = paramRegexp.exec(result[2])) !== null) {
                params.push(+paramResult[0]);
            }

            if (commandLetter === 'M') {
                assert(params.length === 2);
                currentPoint = {x: params[0], y: params[1]};
                subpathStart = {x: params[0], y: params[1]};
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if (commandLetter === 'l') {
                assert(params.length === 2);
                currentPoint.x += params[0];
                currentPoint.y += params[1];
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if ((commandLetter === 'c') || (commandLetter === 'C')) {
                assert(params.length === 6);
                if (commandLetter === 'c') {
                    currentPoint.x += params[4];
                    currentPoint.y += params[5];
                } else if (commandLetter === 'C') {
                    currentPoint.x = params[4];
                    currentPoint.y = params[5];
                } else {
                    assert(false);
                }
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if (commandLetter === 's') {
                assert(params.length === 4);
                currentPoint.x += params[2];
                currentPoint.y += params[3];
                importedPoly.push({x: currentPoint.x, y: currentPoint.y});
            } else if ((commandLetter === 'z') || (commandLetter === 'Z')) {
                assert(params.length === 0);
            } else {
                console.log("unhandled command", commandLetter);
                assert(false);
            }
        }

        var centroid = polyCentroid(importedPoly);
        for (var i = 0; i < importedPoly.length; i++) {
            importedPoly[i].x -= centroid.x;
            importedPoly[i].y -= centroid.y;
        }

        polygon = importedPoly;
        updatePolygonElem();

        outputCenter = null;
        outputRadius = 0;
        updateOutputRegion();
    }

    interactionElem.addEventListener("contextmenu", function (e) {
        e.preventDefault();
        if (currentMode == MODE_DRAW) {
            currentMode = MODE_NOTHING;
            polygon.pop();
            updatePolygonElem();
        }
    }, false);

    interactionElem.addEventListener("mousedown", function (e) {
        if (currentMode === MODE_NOTHING) {
            if (e.button === 0) {
                if (polygon) {
                    // enter drag mode
                    currentMode = MODE_PAN;
                    dragPrev = {x: e.pageX, y: e.pageY};
                } else {
                    currentMode = MODE_DRAW;
                    polygon = [];

                    var p = eventToElemCoords(e, polyContainerElem);
                    polygon.push(p);
                    polygon.push(p); // push again, so we have two points
                    updatePolygonElem();
                }
            } else if (e.button === 2) {
                // right click
                currentMode = MODE_ZOOM;
                dragPrev = {x: e.pageX, y: e.pageY};
            }
        } else if (currentMode === MODE_DRAW) {
            if (e.button === 0) {
                // add another point
                var p = eventToElemCoords(e, polyContainerElem);
                polygon.push(p);
                updatePolygonElem();
            }
        }
    }, false);

    interactionElem.addEventListener("mouseup", function (e) {
        if (currentMode === MODE_PAN) {
            currentMode = MODE_NOTHING;
        } else if (currentMode === MODE_ZOOM) {
            currentMode = MODE_NOTHING;
        }
    }, false);

    interactionElem.addEventListener("mousemove", function (e) {
        if (currentMode === MODE_NOTHING) {
            if (polygon) {
                var cur = eventToElemCoords(e, polyContainerElem);
                var radius = 10.0;
                highlightedVertexIndex = nearestVertex(polygon, cur, radius);
                updatedHighlightedVertex();
            }
        } else if (currentMode === MODE_DRAW) {
            var p = eventToElemCoords(e, polyContainerElem);
            polygon[polygon.length-1] = p;
            updatePolygonElem();
        } else if (currentMode === MODE_PAN) {
            var prev = pageToElemCoords(dragPrev, polyContainerElem);
            var cur = eventToElemCoords(e, polyContainerElem);

            var dx = cur.x - prev.x;
            var dy = cur.y - prev.y;
            panSumX += dx;
            panSumY += dy;
            setPanZoom();

            dragPrev = {x: e.pageX, y: e.pageY};
        } else if (currentMode === MODE_ZOOM) {
            var dy = e.pageY - dragPrev.y;
            zoomSumY += dy;
            setPanZoom();
            dragPrev = {x: e.pageX, y: e.pageY};
        } else if (currentMode === MODE_MARK_OUTPUT) {
            var p = eventToElemCoords(e, polyContainerElem);
            outputRadius = pointDist(p, outputCenter);
            updateOutputRegion();
        }
        lastMousePos = {x: e.pageX, y: e.pageY};
    }, false);

    document.getElementById("clear-button").addEventListener("click", function(e) {
        currentMode = MODE_NOTHING;
        polygon = null;
        updatePolygonElem();

        outputCenter = null;
        outputRadius = 0;
        updateOutputRegion();
    }, false);

    document.getElementById("import-file-button").addEventListener("click", function(e) {
        var fileInput = document.getElementById("import-file-input");
        if (fileInput.files.length === 1) {
            var reader = new FileReader();
            reader.onload = function(e) {
                importSVG(e.target.result);
            }
            reader.readAsText(fileInput.files[0]);
        }
    }, false);

    // toggling control panel
    var controlPanelElem = document.getElementById("control-panel");
    var controlPanelShown = true;
    document.addEventListener("keydown", function(e) {
        if (e.keyCode === 27) {
            if (controlPanelShown) {
                controlPanelElem.setAttribute("style", "display:none");
            } else {
                controlPanelElem.setAttribute("style", "display:block");
            }
            controlPanelShown = !controlPanelShown;
        } else if (e.keyCode === 'O'.charCodeAt(0)) {
            if (currentMode === MODE_NOTHING) {
                // mark output region
                currentMode = MODE_MARK_OUTPUT;
                outputCenter = pageToElemCoords(lastMousePos, polyContainerElem);
                outputRadius = 0;
            }
        }
    }, false);

    document.addEventListener("keyup", function(e) {
        if (e.keyCode === 'O'.charCodeAt(0)) {
            if (currentMode === MODE_MARK_OUTPUT) {
                currentMode = MODE_NOTHING;
            }
        }
    }, false);

}, false);
</script>
</body>
</html>
